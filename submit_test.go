// Copyright 2015 Tony Bai.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     httpg//www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// See the License for the specific language governing permissions and
// limitations under the License.

package cmpp_test

import (
	"fmt"
	"testing"

	"github.com/bigwhite/gocmpp"
	"github.com/bigwhite/gocmpp/utils"
)

var (
	pkTotal            uint8    = 1
	pkNumber           uint8    = 1
	registeredDelivery uint8    = 1
	msgLevel           uint8    = 1
	serviceId          string   = "test"
	feeUserType        uint8    = 2
	feeTerminalId      string   = "13500002696"
	feeTerminalType    uint8    = 0
	msgFmt             uint8    = 8
	msgSrc             string   = "900001"
	feeType            string   = "02"
	feeCode            string   = "10"
	validTime          string   = "151105131555101+"
	atTime             string   = ""
	srcId              string   = "900001"
	destUsrTl          uint8    = 1
	destTerminalId     []string = []string{"13500002696"}
	destTerminalType   uint8    = 0
	utf8Content                 = "测试gocmpp submit"
	msgLength          uint8
	msgContent         string
)

func init() {
	var err error
	msgContent, err = cmpputils.Utf8ToUcs2(utf8Content)
	if err != nil {
		fmt.Println("utf8 to ucs2 transform err:", err)
		return
	}
	msgLength = uint8(len(msgContent))
}

func TestCmpp2SubmitReqPktPack(t *testing.T) {
	p := &cmpp.Cmpp2SubmitReqPkt{
		PkTotal:            pkTotal,
		PkNumber:           pkNumber,
		RegisteredDelivery: registeredDelivery,
		MsgLevel:           msgLevel,
		ServiceId:          serviceId,
		FeeUserType:        feeUserType,
		FeeTerminalId:      feeTerminalId,
		MsgFmt:             msgFmt,
		MsgSrc:             msgSrc,
		FeeType:            feeType,
		FeeCode:            feeCode,
		ValidTime:          validTime,
		AtTime:             atTime,
		SrcId:              srcId,
		DestUsrTl:          destUsrTl,
		DestTerminalId:     destTerminalId,
		MsgLength:          msgLength,
		MsgContent:         msgContent,
	}

	data, err := p.Pack(seqId)
	if err != nil {
		t.Fatal("Cmpp2SubmitReqPkt pack error:", err)
	}

	if p.SeqId != seqId {
		t.Fatalf("After pack, seqId is %d, not equal to expected: %d\n", p.SeqId, seqId)
	}

	dataExpected := []byte{
		0x00, 0x00, 0x00, 0xbd, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x74, 0x65, 0x73, 0x74, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x02, 0x31, 0x33, 0x35, 0x30, 0x30, 0x30, 0x30, 0x32, 0x36, 0x39, 0x36, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x39, 0x30, 0x30, 0x30, 0x30,
		0x31, 0x30, 0x32, 0x31, 0x30, 0x00, 0x00, 0x00, 0x00, 0x31, 0x35, 0x31, 0x31, 0x30, 0x35, 0x31,
		0x33, 0x31, 0x35, 0x35, 0x35, 0x31, 0x30, 0x31, 0x2b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x39, 0x30, 0x30, 0x30, 0x30,
		0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x01, 0x31, 0x33, 0x35, 0x30, 0x30, 0x30, 0x30, 0x32, 0x36, 0x39, 0x36, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x6d, 0x4b, 0x8b, 0xd5, 0x00, 0x67, 0x00, 0x6f, 0x00,
		0x63, 0x00, 0x6d, 0x00, 0x70, 0x00, 0x70, 0x00, 0x20, 0x00, 0x73, 0x00, 0x75, 0x00, 0x62, 0x00,
		0x6d, 0x00, 0x69, 0x00, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}

	l1 := len(data)
	l2 := len(dataExpected)
	if l1 != l2 {
		t.Fatalf("After pack, data length is %d, not equal to length expected: %d\n", l1, l2)
	}

	for i := 0; i < l1; i++ {
		if data[i] != dataExpected[i] {
			t.Fatalf("After pack, data[%d] is %x, not equal to dataExpected[%d]: %x\n", i, data[i], i, dataExpected[i])
		}
	}
}

func TestCmpp2SubmitReqPktUnpack(t *testing.T) {
	data := []byte{
		0x00, 0x00, 0x00, 0xbd, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x74, 0x65, 0x73, 0x74, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x02, 0x31, 0x33, 0x35, 0x30, 0x30, 0x30, 0x30, 0x32, 0x36, 0x39, 0x36, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x39, 0x30, 0x30, 0x30, 0x30,
		0x31, 0x30, 0x32, 0x31, 0x30, 0x00, 0x00, 0x00, 0x00, 0x31, 0x35, 0x31, 0x31, 0x30, 0x35, 0x31,
		0x33, 0x31, 0x35, 0x35, 0x35, 0x31, 0x30, 0x31, 0x2b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x39, 0x30, 0x30, 0x30, 0x30,
		0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x01, 0x31, 0x33, 0x35, 0x30, 0x30, 0x30, 0x30, 0x32, 0x36, 0x39, 0x36, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x6d, 0x4b, 0x8b, 0xd5, 0x00, 0x67, 0x00, 0x6f, 0x00,
		0x63, 0x00, 0x6d, 0x00, 0x70, 0x00, 0x70, 0x00, 0x20, 0x00, 0x73, 0x00, 0x75, 0x00, 0x62, 0x00,
		0x6d, 0x00, 0x69, 0x00, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}

	p := &cmpp.Cmpp2SubmitReqPkt{}
	err := p.Unpack(data[8:])
	if err != nil {
		t.Fatal("Cmpp2SubmitReqPkt unpack error:", err)
	}

	var resultSet = []struct {
		name          string
		value         interface{}
		expectedValue interface{}
	}{
		{"SeqId", p.SeqId, seqId},
		{"PkTotal", p.PkTotal, pkTotal},
		{"PkNumber", p.PkNumber, pkNumber},
		{"MsgLevel", p.MsgLevel, msgLevel},
		{"ServiceId", p.ServiceId, serviceId},
		{"FeeUserType", p.FeeUserType, feeUserType},
		{"FeeTerminalId", p.FeeTerminalId, feeTerminalId},
		{"MsgFmt", p.MsgFmt, msgFmt},
		{"MsgSrc", p.MsgSrc, msgSrc},
		{"FeeType", p.FeeType, feeType},
		{"FeeCode", p.FeeCode, feeCode},
		{"ValidTime", p.ValidTime, validTime},
		{"AtTime", p.AtTime, atTime},
		{"SrcId", p.SrcId, srcId},
		{"DestUsrTl", p.DestUsrTl, destUsrTl},
		{"DestTerminalId", p.DestTerminalId[0], destTerminalId[0]},
		{"MsgLength", p.MsgLength, msgLength},
		{"MsgContent", p.MsgContent, msgContent},
	}

	for _, r := range resultSet {
		if r.value != r.expectedValue {
			t.Fatalf("After unpack, %s in packet is %#v, not equal to the expected value: %#v\n", r.name, r.value, r.expectedValue)
		}
	}
}

func TestCmpp2SubmitRspPktPack(t *testing.T) {
	p := &cmpp.Cmpp2SubmitRspPkt{
		MsgId:  12878564852733378560, //0xb2, 0xb9, 0xda, 0x80, 0x00, 0x01, 0x00, 0x00
		Result: 0,
	}

	data, err := p.Pack(seqId)
	if err != nil {
		t.Fatal("Cmpp2SubmitRspPkt pack error:", err)
	}

	if p.SeqId != seqId {
		t.Fatalf("After pack, seqId is %d, not equal to expected: %d\n", p.SeqId, seqId)
	}

	dataExpected := []byte{
		0x00, 0x00, 0x00, 0x15, 0x80, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x17,
		0xb2, 0xb9, 0xda, 0x80, 0x00, 0x01, 0x00, 0x00, 0x00,
	}

	l1 := len(data)
	l2 := len(dataExpected)
	if l1 != l2 {
		t.Fatalf("After pack, data length is %d, not equal to length expected: %d\n", l1, l2)
	}

	for i := 0; i < l1; i++ {
		if data[i] != dataExpected[i] {
			t.Fatalf("After pack, data[%d] is %x, not equal to dataExpected[%d]: %x\n", i, data[i], i, dataExpected[i])
		}
	}
}

func TestCmpp2SubmitRspPktUnpack(t *testing.T) {
	data := []byte{
		0x00, 0x00, 0x00, 0x15, 0x80, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x17,
		0xb2, 0xb9, 0xda, 0x80, 0x00, 0x01, 0x00, 0x00, 0x00,
	}

	p := &cmpp.Cmpp2SubmitRspPkt{}
	err := p.Unpack(data[8:])
	if err != nil {
		t.Fatal("Cmpp2SubmitRspPkt unpack error:", err)
	}

	if p.SeqId != seqId {
		t.Fatalf("After unpack, seqId in packet is %x, not equal to the expected value: %x\n", p.SeqId, seqId)
	}

	var msgId uint64 = 12878564852733378560 //0xb2, 0xb9, 0xda, 0x80, 0x00, 0x01, 0x00, 0x00
	if p.MsgId != msgId {
		t.Fatalf("After unpack, msgId in packet is %d, not equal to the expected value: %d\n", p.MsgId, msgId)
	}

	if p.Result != 0x0 {
		t.Fatalf("After unpack, result in packet is %d, not equal to the expected value: %d\n", p.Result, 0)
	}
}

func TestCmpp3SubmitReqPktPack(t *testing.T) {
	p := &cmpp.Cmpp3SubmitReqPkt{
		PkTotal:            pkTotal,
		PkNumber:           pkNumber,
		RegisteredDelivery: registeredDelivery,
		MsgLevel:           msgLevel,
		ServiceId:          serviceId,
		FeeUserType:        feeUserType,
		FeeTerminalId:      feeTerminalId,
		FeeTerminalType:    feeTerminalType,
		MsgFmt:             msgFmt,
		MsgSrc:             msgSrc,
		FeeType:            feeType,
		FeeCode:            feeCode,
		ValidTime:          validTime,
		AtTime:             atTime,
		SrcId:              srcId,
		DestUsrTl:          destUsrTl,
		DestTerminalId:     destTerminalId,
		DestTerminalType:   destTerminalType,
		MsgLength:          msgLength,
		MsgContent:         msgContent,
	}

	data, err := p.Pack(seqId)
	if err != nil {
		t.Fatal("Cmpp3SubmitReqPkt pack error:", err)
	}

	if p.SeqId != seqId {
		t.Fatalf("After pack, seqId is %d, not equal to expected: %d\n", p.SeqId, seqId)
	}

	dataExpected := []byte{
		0x00, 0x00, 0x00, 0xe1, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x74, 0x65, 0x73, 0x74, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x02, 0x31, 0x33, 0x35, 0x30, 0x30, 0x30, 0x30, 0x32, 0x36, 0x39, 0x36, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x39, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x32, 0x31,
		0x30, 0x00, 0x00, 0x00, 0x00, 0x31, 0x35, 0x31, 0x31, 0x30, 0x35, 0x31, 0x33, 0x31, 0x35, 0x35,
		0x35, 0x31, 0x30, 0x31, 0x2b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x39, 0x30, 0x30, 0x30, 0x30, 0x31, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x31, 0x33, 0x35,
		0x30, 0x30, 0x30, 0x30, 0x32, 0x36, 0x39, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x6d,
		0x4b, 0x8b, 0xd5, 0x00, 0x67, 0x00, 0x6f, 0x00, 0x63, 0x00, 0x6d, 0x00, 0x70, 0x00, 0x70, 0x00,
		0x20, 0x00, 0x73, 0x00, 0x75, 0x00, 0x62, 0x00, 0x6d, 0x00, 0x69, 0x00, 0x74, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00,
	}

	l1 := len(data)
	l2 := len(dataExpected)
	if l1 != l2 {
		t.Fatalf("After pack, data length is %d, not equal to length expected: %d\n", l1, l2)
	}

	for i := 0; i < l1; i++ {
		if data[i] != dataExpected[i] {
			t.Fatalf("After pack, data[%d] is %x, not equal to dataExpected[%d]: %x\n", i, data[i], i, dataExpected[i])
		}
	}
}

func TestCmpp3SubmitReqPktUnpack(t *testing.T) {
	data := []byte{
		0x00, 0x00, 0x00, 0xe1, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x74, 0x65, 0x73, 0x74, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x02, 0x31, 0x33, 0x35, 0x30, 0x30, 0x30, 0x30, 0x32, 0x36, 0x39, 0x36, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x39, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x32, 0x31,
		0x30, 0x00, 0x00, 0x00, 0x00, 0x31, 0x35, 0x31, 0x31, 0x30, 0x35, 0x31, 0x33, 0x31, 0x35, 0x35,
		0x35, 0x31, 0x30, 0x31, 0x2b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x39, 0x30, 0x30, 0x30, 0x30, 0x31, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x31, 0x33, 0x35,
		0x30, 0x30, 0x30, 0x30, 0x32, 0x36, 0x39, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x6d,
		0x4b, 0x8b, 0xd5, 0x00, 0x67, 0x00, 0x6f, 0x00, 0x63, 0x00, 0x6d, 0x00, 0x70, 0x00, 0x70, 0x00,
		0x20, 0x00, 0x73, 0x00, 0x75, 0x00, 0x62, 0x00, 0x6d, 0x00, 0x69, 0x00, 0x74, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00,
	}

	p := &cmpp.Cmpp3SubmitReqPkt{}
	err := p.Unpack(data[8:])
	if err != nil {
		t.Fatal("Cmpp3SubmitReqPkt unpack error:", err)
	}

	var resultSet = []struct {
		name          string
		value         interface{}
		expectedValue interface{}
	}{
		{"SeqId", p.SeqId, seqId},
		{"PkTotal", p.PkTotal, pkTotal},
		{"PkNumber", p.PkNumber, pkNumber},
		{"MsgLevel", p.MsgLevel, msgLevel},
		{"ServiceId", p.ServiceId, serviceId},
		{"FeeUserType", p.FeeUserType, feeUserType},
		{"FeeTerminalId", p.FeeTerminalId, feeTerminalId},
		{"FeeTerminalType", p.FeeTerminalType, feeTerminalType},
		{"MsgFmt", p.MsgFmt, msgFmt},
		{"MsgSrc", p.MsgSrc, msgSrc},
		{"FeeType", p.FeeType, feeType},
		{"FeeCode", p.FeeCode, feeCode},
		{"ValidTime", p.ValidTime, validTime},
		{"AtTime", p.AtTime, atTime},
		{"SrcId", p.SrcId, srcId},
		{"DestUsrTl", p.DestUsrTl, destUsrTl},
		{"DestTerminalId", p.DestTerminalId[0], destTerminalId[0]},
		{"DestTerminalType", p.DestTerminalType, destTerminalType},
		{"MsgLength", p.MsgLength, msgLength},
		{"MsgContent", p.MsgContent, msgContent},
		{"LinkId", p.LinkId, ""},
	}

	for _, r := range resultSet {
		if r.value != r.expectedValue {
			t.Fatalf("After unpack, %s in packet is %#v, not equal to the expected value: %#v\n", r.name, r.value, r.expectedValue)
		}
	}
}

func TestCmpp3SubmitRspPktPack(t *testing.T) {
	p := &cmpp.Cmpp3SubmitRspPkt{
		MsgId:  12878564852733378560, //0xb2, 0xb9, 0xda, 0x80, 0x00, 0x01, 0x00, 0x00
		Result: 0,
	}

	data, err := p.Pack(seqId)
	if err != nil {
		t.Fatal("Cmpp3SubmitRspPkt pack error:", err)
	}

	if p.SeqId != seqId {
		t.Fatalf("After pack, seqId is %d, not equal to expected: %d\n", p.SeqId, seqId)
	}

	dataExpected := []byte{
		0x00, 0x00, 0x00, 0x18, 0x80, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x17,
		0xb2, 0xb9, 0xda, 0x80, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}

	l1 := len(data)
	l2 := len(dataExpected)
	if l1 != l2 {
		t.Fatalf("After pack, data length is %d, not equal to length expected: %d\n", l1, l2)
	}

	for i := 0; i < l1; i++ {
		if data[i] != dataExpected[i] {
			t.Fatalf("After pack, data[%d] is %x, not equal to dataExpected[%d]: %x\n", i, data[i], i, dataExpected[i])
		}
	}
}

func TestCmpp3SubmitRspPktUnpack(t *testing.T) {
	data := []byte{
		0x00, 0x00, 0x00, 0x18, 0x80, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x17,
		0xb2, 0xb9, 0xda, 0x80, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}

	p := &cmpp.Cmpp3SubmitRspPkt{}
	err := p.Unpack(data[8:])
	if err != nil {
		t.Fatal("Cmpp3SubmitRspPkt unpack error:", err)
	}

	if p.SeqId != seqId {
		t.Fatalf("After unpack, seqId in packet is %x, not equal to the expected value: %x\n", p.SeqId, seqId)
	}

	var msgId uint64 = 12878564852733378560 //0xb2, 0xb9, 0xda, 0x80, 0x00, 0x01, 0x00, 0x00
	if p.MsgId != msgId {
		t.Fatalf("After unpack, msgId in packet is %d, not equal to the expected value: %d\n", p.MsgId, msgId)
	}

	if p.Result != 0x0 {
		t.Fatalf("After unpack, result in packet is %d, not equal to the expected value: %d\n", p.Result, 0)
	}
}
